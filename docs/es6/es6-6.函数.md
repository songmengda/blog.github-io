# ES6函数

## 基本用法

### 函数默认值

ES6 之前，不能直接为函数的参数指定默认值,ES6 允许为函数的参数设置默认值，直接写在参数定义的后面。
```javascript
//es5
function fn(name,age){
  name=name||'小丑巴基'
}

//es6
function fn(name='小丑巴基',age){

}
```
### 函数默认值与解构赋值

函数参数的默认值可以与接口赋值的默认值 结合起来使用
```js
function fn({name='红发',age}={}){
  console.,log(name,age)
}
fn()
```
### 参数默认值的位置

定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。
```js
function f(name = '白云', age) {
  return [name, age];
}

f() // [白云, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [白云, 1]
```
### 函数的length属性

当指定了函数的参数默认值之后  length属性将不返回该默认值的个数
```js
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2

// 如果传一个args  rest参数也不计入length属性
(function(...args) {}).length // 0
```

### 作用域

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）
```js
let x = 1; //如果此时，全局变量x不存在，就会报错。

function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // 1
```

## rest参数

ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
```js
function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
```
 rest 参数可以代替arguments变量。
 arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。
 ```js
 // arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
 ```

## 严格模式

ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

## name属性

函数的name属性，返回该函数的函数名。
```js
function demo() {}
demo.name // "demo"


var fn = function () {};

// ES5
fn.name // ""

// ES6
fn.name // "fn"

//如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。
```

## 箭头函数

```js
var f = v => v;

// 等同于
var f = function (v) {
  return v;
};

var f = () => 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};
```

## 注意点

（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

## 不适用的场景

第一个场合是定义对象的方法，且该方法内部包括this。
```js
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}
// cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；
// 如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。

```

第二个场合是需要动态this的时候，也不应使用箭头函数。
```js
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});
//上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。
//另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。
```