# ES6数组

## 扩展运算符

扩展运算符是使用三个点 [...] 它像是rest参数的逆运算 ，因为可以把rest看成将多个数据进行打包到一起。
而扩展运算符是将其展开
```js
console.log(...['李白','杜甫','白居易']) // '李白'  ‘杜甫’ ‘白居易’
```

### 扩展运算符的应用

**(1)复制数组**

因为数组是引用数据类型,直接复制的话，只是复制了底层的数据结构的指针,而不是复制了一个新的数组。
```js
//比如
const names=['巴基大神','白胡子']
const newNames1=names

newNames1[1]='红发'

console.log(names) // ['巴基大神','红发']
// 这样做并不是复制

//ES5 只能通过变通的方法进行复制数组
const newNames2=names.concat()
// 此时的newNames2 是names的克隆 修改newNames2不会对names造成影响

// ES6就更简单了
const newNames3=[...names] // 或者写成 const [...newNames3]=names

```
**(2)合并数组**

ES6提供了很方便的合并数组的写法
```js
const arr1=[1,2]
const arr2=[3,4]

// 合并到一起  
[...arr1,...arr2]  // 得到的这个新数组是对原数组的引用  是浅拷贝
```
**(3)对字符串解构**
```js
const str='我是'
[...str]   // '我' '是' 
```

**(4)对Iterator接口的支持**

所有具有Iterator属性的数据   都可以进行解构赋值

## Array.from()

Array.from()方法可以将类似数组的数据转化成数组, 类似数组的对象（array-like object）和可遍历的对象（包括Set和Map）
```js
let likeArr={
  '0':'a',
  '1':'b',
  '2':'c',
  length:3
}
// ES5 
[].slice.call(likeArr)

// ES6 
Array.from(lileArr)
```

## Array.of()

Array.of()方法可以将一组值，转化为数组
```js
Array.of(1,2,3,4,5) //[1, 2, 3, 4, 5]
```
## copyWithin()

在当前数组内部，将制定位置的成员复制到其他位置(覆盖原有成员),然后返回当前数组,
```js
Array.prototype.copyWithin(target, start = 0, end = this.length)
/*
target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。
*/
```
## find()和findIndex()

数组实例的find方法，可以找出第一个符合条件的数组成员. 他的参数是一个回调函数，所有数组成员依次执行该回调函数 ，直到找到第一个返回值为true的成员，然后返回该成员
```js
[1,2,3,4,5,6,7,8,9].find((n)=> n < 4) // 1
// 三个参数，依次为当前的值、当前的位置和原数组。
[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10
```

数组实例的findIndex方法的用法与find方法类似，返回第一个符合条件的数组成员的位置。如果都不符合条件 则返回-1

## entries() keys() values()
三者都是用于遍历数组,
keys()是对键名的遍历、values()是对键值的遍历、entries()是对键值对的遍历

## includes()
Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似

## flat() 和 flatMap()

flat常用作多维数组转一维数组
如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。

flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。