# 变量声明let和const
---
在js中 声明变量可以通过<code>var</code>来声明一个变量  使用<code>function</code>声明一个函数。
## let命令声明变量

**用法**

而在ES6中 新增了<code>let</code>命令，用来声明变量。区别在于<code>let</code>不会存在变量提升

```javascript
console.log(a)
let a='想睡觉'
console.log(b)
var b='想学习'

a // Uncaught ReferenceError: Cannot access 'a' before initialization
b // undefined 表面b是变量声明了  只是没有赋值操作  存在变量提升
```

---
**暂时性死区的概念**

ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

```javascript
let _lock=true
if(_lock){
   // TDZ开始
  TDZ = '测试死区'; // ReferenceError
  console.log(TDZ); // ReferenceError

  let TDZ; // TDZ结束
  console.log(TDZ); // undefined

  TDZ = 123;
  console.log(TDZ); // 123
}
```

## const命令

**用法**

const声明一个只读的常量。一旦声明，常量的值就不能改变。
```javascript
const name = '巴基大神'
name // ’巴基大神‘

name = '七武海鹰眼';
// TypeError: Assignment to constant variable.
```
---
**不可改动的本质**

本质上<code>const</code>并不是变量的值不可改动，而是变量指向的那个**内存地址所保存的数据**不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，**保存的只是一个指向实际数据的指针**，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

```javascript
const arr=[]
arr.push('is ok') // 可以执行
console.log(arr.length) // 1
arr=['new'] //Uncaught TypeError: Assignment to constant variable.
```

---
**如何取到顶层对象**
```javascript
// 方法一
(typeof window !== 'undefined'? window: (typeof process === 'object' &&typeof require === 'function' && typeof global === 'object')? global: this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```

<script>

</script>